# 유니티 UI 시스템 실습 정리
### 날짜
2025.08.07 

### 오늘의 목표
UI 시스템의 작동원리와 구조를 이해하고, 실전 과제로 캐릭터 강화 UI를 직접 구성해봄. 단순한 버튼 연결을 넘어, 인벤토리 + 스탯 + 문자열 파싱까지 포함된 시스템 통합 설계를 실험적으로 구현.

### 핵심 포인트 요약
UI는 캔버스(Canvas) 안에 있어야만 작동함.
Render Mode, Canvas Scaler 설정이 화면비 + UI 반응형의 핵심.

실전 프로젝트에선 하나의 캔버스에 모든 걸 몰아넣으면 렌더링 부하 ↑
자주 갱신되는 UI는 별도 캔버스로 분리하는 게 성능상 유리.

TMP(TextMeshPro)는 기본 텍스트보다 훨씬 강력함. 실전 적용 예정.

드로우 콜 최적화를 위해선 동일 머티리얼 & 텍스처 재활용
(→ 성능 떨어질 UI는 Pixel Perfect 제거 권장)

UI 이벤트(EventSystem)와 Graphic Raycast는 성능 병목 포인트
→ Profiler로 추적 필수

### 오늘 만든 시스템 요약
####구성요소	설명
UpgradeUI.cs	버튼 누르면 강화 실행, UI 텍스트 반영
UnitStat.cs	공격력, 방어력 수치 보관 및 강화 시 수치 증가 처리
UnityInventory.cs	강화에 필요한 골드, 루비, 사파이어, 마력석 수량 보관
Sample.cs	강화 요구사항을 문자열로 받아서, Split() 활용해 자원 항목만 추출

강화 요구사항은 배열 materials[]로 저장

"100 골드", "100 골드 + 루비", "200 골드 + 사파이어 + 마력석", "최대 강화 완료"

버튼 누르면:

현재 강화 단계 확인 → 요구 자원 Parse() → 인벤토리 검사

자원이 부족하면 "재화 부족" 메시지 출력

자원이 충분하면 → 스탯 증가 + 재화 차감 → UI 갱신

### 느낀 점
UI는 겉보기와 달리 정보 흐름 제어의 최전선이었다. 단순히 버튼 누른다고 되는 게 아님.

통합 설계를 먼저 잘 짜두면 이후 로직이 술술 풀리는데, 구조가 애매하면 디버깅 지옥.

Sample.cs는 원래 "이게 왜 있어야 하지?" 싶었지만, 유연한 문자열 파싱 → 다국어/다양한 조건식 대응 가능성 확인.

Upgrade()는 결국 숫자 하나 더하는 단순 로직인데, 그 전후 검증 로직이 훨씬 복잡하다는 점 실감.

가장 큰 수확은: UI도 결국 게임 시스템이다. 눈에 보인다고 만만하게 봐선 안 된다.

###다음 목표
지금 만든 강화 UI를 실제 전투 or 인게임 흐름과 연결
→ 강화 결과가 몬스터와의 전투에서 실질적으로 작동하는 구조 만들기

Tag, Layer, OnTriggerEnter()를 조건 분기 처리에 적극 활용

완성된 미니게임 구조에서 각 구성 요소를 분해하고 직접 재작성해보기
